## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?

A - inside def save()

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?

A - properties.sql

Q3. In `console.rb`, which lines modify the database?

A - lines with .save() and .delete()

Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?

A - The database assigns new entries an id automatically.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?

A - @id = db.exec_prepared("save", values)[0]["id"].to_i

Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?

A - Because the database has not yet assigned the ID.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

A - The ones represented by instance methods are functions that work on one database entry at a time. The class methods can work on all of them at once.

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?

A - A PG data structure that is like an array.

Q9. Why do we use prepared statements when performing database operations?

A - To secure against SQL Injection attempts by malicious users.

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?

A - find_by_id takes in the id assigned by the database.
    find_by_address takes in the address of an entry.

Q11. What are their return values?
    Both should return the corresponding database entry.
